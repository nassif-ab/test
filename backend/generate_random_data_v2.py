import random
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from database import SessionLocal
import models
from crud import get_users, get_user_by_username, get_user_by_email, create_user
from schemas import UserCreate
import time

# G√©n√©rateur de donn√©es utilisateur
def generate_user_data(count=300):
    """G√©n√®re 300 utilisateurs avec des donn√©es r√©alistes"""
    
    # Listes de pr√©noms et noms en fran√ßais et arabe
    prenoms_fr = [
        "Ahmed", "Mohamed", "Fatima", "Aicha", "Omar", "Khadija", "Youssef", "Amina",
        "Hassan", "Nadia", "Karim", "Samira", "Rachid", "Leila", "Mehdi", "Zineb",
        "Abdelkader", "Hafsa", "Said", "Malika", "Bilal", "Souad", "Tarik", "Ghita",
        "Khalid", "Rajae", "Hamza", "Siham", "Amine", "Kenza", "Othmane", "Imane",
        "Abderrahim", "Hanane", "Driss", "Widad", "Mustapha", "Hayat", "Saad", "Chaima",
        "Adil", "Rim", "Jamal", "Asma", "Nordine", "Houda", "Zakaria", "Meryem",
        "Reda", "Salma", "Ismail", "Naima", "Fouad", "Laila", "Hicham", "Sara"
    ]
    
    noms_fr = [
        "Benali", "Alami", "Fassi", "Tazi", "Bennani", "Kadiri", "Lamrani", "Berrada",
        "Cherif", "Idrissi", "Hakim", "Naciri", "Squalli", "Cherkaoui", "Benlahcen",
        "Andaloussi", "Belkadi", "Rami", "Sabir", "Tahiri", "Benkirane", "Rais",
        "Benabdellah", "Amrani", "Belkacem", "Benomar", "Filali", "Benjelloun",
        "Kettani", "Benchekroun", "Ghali", "Mekouar", "Skalli", "Benslimane",
        "Bouchentouf", "Lahlou", "Benali", "Chraibi", "Berrechid", "Boukhris"
    ]
    
    domaines_email = ["gmail.com", "hotmail.com", "yahoo.fr", "outlook.com", "email.com"]
    
    users_data = []
    
    for i in range(count):
        prenom = random.choice(prenoms_fr)
        nom = random.choice(noms_fr)
        
        # G√©n√©rer un nom d'utilisateur unique
        username_base = f"{prenom.lower()}{nom.lower()}"
        username = f"{username_base}{random.randint(1, 9999)}"
        
        # G√©n√©rer un email unique
        email = f"{prenom.lower()}.{nom.lower()}{random.randint(1, 999)}@{random.choice(domaines_email)}"
        
        user_data = {
            "username": username,
            "fullName": f"{prenom} {nom}",
            "email": email,
            "password": "123456789",  # Mot de passe par d√©faut
            "is_admin": False
        }
        
        users_data.append(user_data)
    
    return users_data

def create_or_update_user(db: Session, user_data):
    """Cr√©e ou met √† jour un utilisateur"""
    # V√©rifier si l'utilisateur existe d√©j√† par username
    existing_user = get_user_by_username(db, user_data["username"])
    if existing_user:
        return existing_user, "existe"
    
    # V√©rifier si l'utilisateur existe d√©j√† par email
    existing_user = get_user_by_email(db, user_data["email"])
    if existing_user:
        # Modifier l'email pour √©viter les doublons
        user_data["email"] = f"modified_{random.randint(1000, 9999)}_{user_data['email']}"
    
    # Cr√©er le nouvel utilisateur
    try:
        user_create = UserCreate(**user_data)
        new_user = create_user(db, user_create)
        return new_user, "creado"
    except Exception as e:
        print(f"Erreur lors de la cr√©ation de l'utilisateur {user_data['username']}: {e}")
        return None, "erreur"

def get_categories_from_db(db: Session):
    """R√©cup√®re les cat√©gories depuis la base de donn√©es"""
    print("R√©cup√©ration des cat√©gories depuis la base de donn√©es...")
    categories = []
    
    # R√©cup√©rer toutes les cat√©gories uniques depuis la table des posts
    db_categories = db.query(models.Post.categorie).distinct().all()
    
    # Convertir le r√©sultat en liste simple
    for category in db_categories:
        if category[0]:  # V√©rifier que la cat√©gorie n'est pas vide
            categories.append(category[0])
    
    print(f"‚úÖ {len(categories)} cat√©gories trouv√©es dans la base de donn√©es")
    return categories

def get_random_date(start_date, end_date):
    """G√©n√®re une date al√©atoire entre la date de d√©but et la date de fin"""
    time_between_dates = end_date - start_date
    days_between_dates = time_between_dates.days
    if days_between_dates <= 0:
        return start_date
    random_number_of_days = random.randrange(days_between_dates)
    return start_date + timedelta(days=random_number_of_days)

def assign_user_interests(db: Session, categories):
    """Assigne trois cat√©gories d'int√©r√™t √† chaque utilisateur avec diff√©rents niveaux d'interaction"""
    print("Attribution d'int√©r√™ts personnalis√©s aux utilisateurs...")
    
    # R√©cup√©rer tous les utilisateurs et les posts par cat√©gorie
    users = db.query(models.User).all()
    
    # Cr√©er un dictionnaire pour stocker les posts par cat√©gorie
    posts_by_category = {}
    for category in categories:
        posts_by_category[category] = db.query(models.Post).filter(models.Post.categorie == category).all()
    
    # Supprimer les cat√©gories qui n'ont pas de posts
    categories_with_posts = [cat for cat in categories if posts_by_category[cat]]
    
    if not categories_with_posts:
        print("Aucune cat√©gorie avec des posts pour assigner des int√©r√™ts")
        return []
    
    print(f"üìä {len(users)} utilisateurs trouv√©s")
    print(f"üìä {len(categories_with_posts)} cat√©gories avec des posts")
    
    return users

def generate_personalized_visits_and_likes(db: Session, categories, start_date=None, end_date=None):
    """G√©n√®re des visites et likes personnalis√©s selon les int√©r√™ts de chaque utilisateur"""
    print("G√©n√©ration d'interactions personnalis√©es selon les int√©r√™ts...")
    
    # Configuration des dates
    if start_date is None:
        start_date = datetime.now() - timedelta(days=180)
    if end_date is None:
        end_date = datetime.now()
    
    # Assigner les int√©r√™ts et r√©cup√©rer les utilisateurs
    users = assign_user_interests(db, categories)
    if not users:
        print("Aucun utilisateur pour g√©n√©rer des interactions")
        return
    
    # Cr√©er un dictionnaire pour stocker les posts par cat√©gorie
    posts_by_category = {}
    for category in categories:
        posts_by_category[category] = db.query(models.Post).filter(models.Post.categorie == category).all()
    
    # Ensemble pour √©viter la duplication dans les likes
    existing_likes = set()
    likes = db.query(models.Like).all()
    for like in likes:
        existing_likes.add((like.user_id, like.post_id))
    
    # G√©n√©rer des interactions pour chaque utilisateur
    visits_created = 0
    likes_created = 0
    
    print(f"üîÑ G√©n√©ration d'interactions pour {len(users)} utilisateurs...")
    
    for idx, user in enumerate(users):
        if idx % 50 == 0:  # Afficher le progr√®s tous les 50 utilisateurs
            print(f"  Progression: {idx}/{len(users)} utilisateurs trait√©s")
        
        # D√©terminer les cat√©gories disponibles avec des posts
        categories_with_available_posts = [cat for cat in categories if posts_by_category[cat]]
        if not categories_with_available_posts:
            continue
        
        # S√©lectionner 3 cat√©gories diff√©rentes au hasard pour l'utilisateur
        if len(categories_with_available_posts) >= 3:
            selected_categories = random.sample(categories_with_available_posts, 3)
        else:
            selected_categories = categories_with_available_posts.copy()
            while len(selected_categories) < 3 and categories_with_available_posts:
                selected_categories.append(random.choice(categories_with_available_posts))
        
        # Niveau 1: Int√©r√™t √©lev√© (beaucoup de visites et likes)
        if selected_categories:
            high_interest_category = selected_categories[0]
            high_interest_posts = posts_by_category[high_interest_category]
            
            # Cr√©er 15-30 visites pour la cat√©gorie d'int√©r√™t √©lev√©
            if high_interest_posts:
                num_visits = random.randint(15, 30)
                for _ in range(num_visits):
                    post = random.choice(high_interest_posts)
                    visit = models.Visit(
                        post_id=post.id,
                        user_id=user.id,
                        ip_address=f"192.168.{random.randint(1, 255)}.{random.randint(1, 255)}",
                        visit_date=get_random_date(start_date, end_date)
                    )
                    db.add(visit)
                    visits_created += 1
                
                # Cr√©er 8-15 likes pour la cat√©gorie d'int√©r√™t √©lev√©
                num_likes = random.randint(8, 15)
                like_attempts = 0
                likes_added = 0
                
                while likes_added < num_likes and like_attempts < num_likes * 3:
                    like_attempts += 1
                    post = random.choice(high_interest_posts)
                    
                    # V√©rifier si ce like existe d√©j√†
                    if (user.id, post.id) in existing_likes:
                        continue
                    
                    like = models.Like(
                        user_id=user.id,
                        post_id=post.id,
                        created_at=get_random_date(start_date, end_date)
                    )
                    db.add(like)
                    existing_likes.add((user.id, post.id))
                    likes_created += 1
                    likes_added += 1
        
        # Niveau 2: Int√©r√™t moyen (visites fr√©quentes, peu de likes)
        if len(selected_categories) > 1:
            medium_interest_category = selected_categories[1]
            medium_interest_posts = posts_by_category[medium_interest_category]
            
            # Cr√©er 8-15 visites pour la cat√©gorie d'int√©r√™t moyen
            if medium_interest_posts:
                num_visits = random.randint(8, 15)
                for _ in range(num_visits):
                    post = random.choice(medium_interest_posts)
                    visit = models.Visit(
                        post_id=post.id,
                        user_id=user.id,
                        ip_address=f"192.168.{random.randint(1, 255)}.{random.randint(1, 255)}",
                        visit_date=get_random_date(start_date, end_date)
                    )
                    db.add(visit)
                    visits_created += 1
                
                # Cr√©er 2-6 likes pour la cat√©gorie d'int√©r√™t moyen
                num_likes = random.randint(2, 6)
                like_attempts = 0
                likes_added = 0
                
                while likes_added < num_likes and like_attempts < num_likes * 3:
                    like_attempts += 1
                    post = random.choice(medium_interest_posts)
                    
                    # V√©rifier si ce like existe d√©j√†
                    if (user.id, post.id) in existing_likes:
                        continue
                    
                    like = models.Like(
                        user_id=user.id,
                        post_id=post.id,
                        created_at=get_random_date(start_date, end_date)
                    )
                    db.add(like)
                    existing_likes.add((user.id, post.id))
                    likes_created += 1
                    likes_added += 1
        
        # Niveau 3: Int√©r√™t faible (peu de visites, pas de likes)
        if len(selected_categories) > 2:
            low_interest_category = selected_categories[2]
            low_interest_posts = posts_by_category[low_interest_category]
            
            # Cr√©er 1-5 visites pour la cat√©gorie d'int√©r√™t faible
            if low_interest_posts:
                num_visits = random.randint(1, 5)
                for _ in range(num_visits):
                    post = random.choice(low_interest_posts)
                    visit = models.Visit(
                        post_id=post.id,
                        user_id=user.id,
                        ip_address=f"192.168.{random.randint(1, 255)}.{random.randint(1, 255)}",
                        visit_date=get_random_date(start_date, end_date)
                    )
                    db.add(visit)
                    visits_created += 1
        
        # Commit p√©riodique pour √©viter les probl√®mes de m√©moire
        if idx % 25 == 0:
            db.commit()
    
    # Commit final
    db.commit()
    
    print(f"‚úÖ {visits_created} visites personnalis√©es cr√©√©es")
    print(f"‚úÖ {likes_created} likes personnalis√©s cr√©√©s")

def create_users_from_generated_data(db: Session, count=300):
    """Cr√©e ou met √† jour les utilisateurs √† partir des donn√©es g√©n√©r√©es"""
    print(f"Cr√©ation ou mise √† jour de {count} utilisateurs...")
    
    # G√©n√©rer les donn√©es utilisateur
    users_data = generate_user_data(count)
    
    users_created = 0
    users_updated = 0
    users_errors = 0
    
    for i, user_data in enumerate(users_data):
        if i % 50 == 0:  # Afficher le progr√®s tous les 50 utilisateurs
            print(f"  Progression: {i}/{count} utilisateurs trait√©s")
        
        # Cr√©er ou mettre √† jour l'utilisateur
        user, action = create_or_update_user(db, user_data)
        
        if action == "creado":
            users_created += 1
        elif action == "existe":
            users_updated += 1
        else:
            users_errors += 1
    
    print(f"‚úÖ {users_created} utilisateurs cr√©√©s")
    print(f"‚úÖ {users_updated} utilisateurs existants")
    if users_errors > 0:
        print(f"‚ö†Ô∏è {users_errors} erreurs lors de la cr√©ation")

def clean_existing_interactions(db: Session):
    """Nettoie les interactions existantes pour cr√©er de nouvelles interactions"""
    print("Nettoyage des interactions existantes...")
    
    # Supprimer les likes et visites existants
    likes_count = db.query(models.Like).count()
    visits_count = db.query(models.Visit).count()
    
    db.query(models.Like).delete()
    db.query(models.Visit).delete()
    db.commit()
    
    print(f"‚úÖ {likes_count} likes supprim√©s")
    print(f"‚úÖ {visits_count} visites supprim√©es")

def main():
    """Fonction principale"""
    # Cr√©er une session de base de donn√©es
    db = SessionLocal()
    
    try:
        print("=" * 60)
        print("üöÄ G√âN√âRATION DE DONN√âES PERSONNALIS√âES - 300 UTILISATEURS")
        print("=" * 60)
        
        # D√©finir une plage de dates personnalis√©e (3 derniers mois par d√©faut)
        end_date = datetime.now()
        start_date = end_date - timedelta(days=90)  # 3 mois
        
        # Permettre la personnalisation de la plage de dates depuis la ligne de commande
        import sys
        if len(sys.argv) > 2:
            try:
                # Format attendu: YYYY-MM-DD
                start_date = datetime.strptime(sys.argv[1], "%Y-%m-%d")
                end_date = datetime.strptime(sys.argv[2], "%Y-%m-%d")
                print(f"üìÖ Utilisation d'une plage de dates personnalis√©e: {start_date.strftime('%Y-%m-%d')} √† {end_date.strftime('%Y-%m-%d')}")
            except ValueError:
                print("‚ö†Ô∏è Format de date incorrect. Utilisation des valeurs par d√©faut.")
                print("Format correct: python script.py 2025-01-01 2025-05-01")
        else:
            print(f"üìÖ Plage de dates par d√©faut: {start_date.strftime('%Y-%m-%d')} √† {end_date.strftime('%Y-%m-%d')}")
        
        # √âtape 1: Cr√©er ou mettre √† jour 300 utilisateurs
        print("\n" + "=" * 50)
        print("üìù √âTAPE 1: CR√âATION DES UTILISATEURS")
        print("=" * 50)
        create_users_from_generated_data(db, count=300)
        
        # √âtape 2: Nettoyer les interactions existantes (optionnel)
        print("\n" + "=" * 50)
        print("üßπ √âTAPE 2: NETTOYAGE DES INTERACTIONS")
        print("=" * 50)
        response = input("Voulez-vous supprimer les interactions existantes? (o/n): ")
        if response.lower() in ['o', 'oui', 'y', 'yes']:
            clean_existing_interactions(db)
        else:
            print("Conservation des interactions existantes...")
        
        # √âtape 3: R√©cup√©rer les cat√©gories depuis la base de donn√©es
        print("\n" + "=" * 50)
        print("üìÇ √âTAPE 3: R√âCUP√âRATION DES CAT√âGORIES")
        print("=" * 50)
        categories = get_categories_from_db(db)
        
        if not categories:
            print("‚ùå Aucune cat√©gorie trouv√©e dans la base de donn√©es!")
            print("Assurez-vous d'avoir des posts avec des cat√©gories dans votre base de donn√©es.")
            return
        
        # √âtape 4: G√©n√©rer des interactions personnalis√©es selon les int√©r√™ts
        print("\n" + "=" * 50)
        print("üéØ √âTAPE 4: G√âN√âRATION DES INTERACTIONS")
        print("=" * 50)
        generate_personalized_visits_and_likes(db, categories, start_date=start_date, end_date=end_date)
        
        # R√©sum√© final
        print("\n" + "=" * 60)
        print("üéâ G√âN√âRATION TERMIN√âE AVEC SUCC√àS!")
        print("=" * 60)
        
        # Statistiques finales
        total_users = db.query(models.User).count()
        total_visits = db.query(models.Visit).count()
        total_likes = db.query(models.Like).count()
        total_posts = db.query(models.Post).count()
        
        print(f"üìä STATISTIQUES FINALES:")
        print(f"   üë• Utilisateurs totaux: {total_users}")
        print(f"   üìù Posts totaux: {total_posts}")
        print(f"   üëÅÔ∏è Visites totales: {total_visits}")
        print(f"   ‚ù§Ô∏è Likes totaux: {total_likes}")
        print(f"   üìÇ Cat√©gories: {len(categories)}")
        
        print(f"\nüí° Pour am√©liorer les recommandations, ex√©cutez le script de formation:")
        print(f"   python scheduled_training.py")
        
    except Exception as e:
        print(f"‚ùå Erreur lors de la g√©n√©ration des donn√©es personnalis√©es: {e}")
        import traceback
        traceback.print_exc()
    
    finally:
        # Fermer la session
        db.close()
        print("\nüîí Session de base de donn√©es ferm√©e.")

if __name__ == "__main__":
    main()